'use strict';

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

(function (global, factory) {
  (typeof exports === 'undefined' ? 'undefined' : _typeof(exports)) === 'object' && typeof module !== 'undefined' ? module.exports = factory() : typeof define === 'function' && define.amd ? define(factory) : (global = global || self, global.scrollama = factory());
})(undefined, function () {
  'use strict';

  // DOM helper functions

  // public

  function selectAll(selector) {
    var parent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : document;

    if (typeof selector === 'string') {
      return Array.from(parent.querySelectorAll(selector));
    } else if (selector instanceof Element) {
      return [selector];
    } else if (selector instanceof NodeList) {
      return Array.from(selector);
    } else if (selector instanceof Array) {
      return selector;
    }
    return [];
  }

  function scrollama() {
    var cb = {};
    var steps = [];
    var globalOffset = void 0;

    var previousYOffset = 0;
    var progressThreshold = 0;

    var direction = void 0;

    var isEnabled = false;
    var isProgressMode = false;
    var isTriggerOnce = false;

    var exclude = [];

    /* HELPERS */
    function err(msg) {
      console.error('scrollama error: ' + msg);
    }

    function reset() {
      cb = {
        stepEnter: function stepEnter() {},
        stepExit: function stepExit() {},
        stepProgress: function stepProgress() {}
      };
      exclude = [];
    }

    function getIndex(node) {
      return +node.getAttribute('data-scrollama-index');
    }

    function updateDirection() {
      if (window.pageYOffset > previousYOffset) direction = 'down';else if (window.pageYOffset < previousYOffset) direction = 'up';
      previousYOffset = window.pageYOffset;
    }

    function handleResize() {
      steps = steps.map(function (step) {
        return _extends({}, step, {
          height: step.node.offsetHeight
        });
      });

      if (isEnabled) updateObservers();
    }

    function handleEnable(shouldEnable) {
      if (shouldEnable && !isEnabled) updateObservers();
      if (!shouldEnable && isEnabled) disconnectObservers();
      isEnabled = shouldEnable;
    }

    function createProgressThreshold(height) {
      var count = Math.ceil(height / progressThreshold);
      var t = [];
      var ratio = 1 / count;
      for (var i = 0; i < count + 1; i += 1) {
        t.push(i * ratio);
      }
      return t;
    }

    function parseOffset(x) {
      if (typeof x === 'string' && x.indexOf('px') > 0) {
        var v = +x.replace('px', '');
        if (!isNaN(v)) return { format: 'pixels', value: v };else {
          err("offset value must be in 'px' format. Fallback to 0.5.");
          return { format: 'percent', value: 0.5 };
        }
      } else if (typeof x === 'number' || !isNaN(+x)) {
        if (x > 1) err('offset value is greater than 1. Fallback to 1.');
        if (x < 0) err('offset value is lower than 0. Fallback to 0.');
        return { format: 'percent', value: Math.min(Math.max(0, x), 1) };
      }
      return null;
    }

    /* NOTIFY CALLBACKS */
    function notifyProgress(element, progress) {
      var index = getIndex(element);
      if (progress !== undefined) steps[index].progress = progress;
      var resp = { element: element, index: index, progress: steps[index].progress };

      if (steps[index].state === 'enter') cb.stepProgress(resp);
    }

    function notifyStepEnter(element, dir) {
      var check = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

      var index = getIndex(element);
      var step = steps[index];
      var response = { element: element, index: index, direction: dir };

      step.direction = dir;
      step.state = 'enter';

      // if (isPreserveOrder && check && dir === 'down') notifyOthers(index, 'above');
      // if (isPreserveOrder && check && dir === 'up') notifyOthers(index, 'below');

      if (!exclude[index]) cb.stepEnter(response);
      if (isTriggerOnce) exclude[index] = true;
    }

    function notifyStepExit(element, dir) {
      var index = getIndex(element);
      var step = steps[index];

      if (!step.state) return false;

      var response = { element: element, index: index, direction: dir };

      if (isProgressMode) {
        if (dir === 'down' && step.progress < 1) notifyProgress(element, 1);else if (dir === 'up' && step.progress > 0) notifyProgress(element, 0);
      }

      step.direction = dir;
      step.state = 'exit';

      cb.stepExit(response);
    }

    /* OBSERVER - INTERSECT HANDLING */
    function resizeStep(_ref) {
      var entry = _ref[0];

      var index = getIndex(entry.target);
      var step = steps[index];
      var h = entry.target.offsetHeight;
      if (h !== step.height) {
        step.height = h;
        disconnectObserver(step);
        updateStepObserver(step);
        updateResizeObserver(step); // todo exclude
      }
    }

    function intersectStep(_ref2) {
      var entry = _ref2[0];

      updateDirection();
      var isIntersecting = entry.isIntersecting,
          intersectionRatio = entry.intersectionRatio,
          target = entry.target;

      if (isIntersecting) notifyStepEnter(target, direction);else notifyStepExit(target, direction);
    }

    function intersectProgress(_ref3) {
      var entry = _ref3[0];

      updateDirection();
      var index = getIndex(entry.target);
      var step = steps[index];
      var isIntersecting = entry.isIntersecting,
          intersectionRatio = entry.intersectionRatio,
          target = entry.target;

      if (isIntersecting && step.state === 'enter') notifyProgress(target, intersectionRatio);
    }

    /*  OBSERVER - CREATION */
    function updateResizeObserver(step) {
      var observer = new ResizeObserver(resizeStep);
      observer.observe(step.node);
      step.observers.resize = observer;
    }

    function updateResizeObservers() {
      steps.forEach(updateResizeObserver);
    }

    function updateStepObserver(step) {
      var h = window.innerHeight;
      var off = step.offset || globalOffset;
      var factor = off.format === 'pixels' ? 1 : h;
      var offset = off.value * factor;
      var marginTop = step.height / 2 - offset;
      var marginBottom = step.height / 2 - (h - offset);
      var rootMargin = marginTop + 'px 0px ' + marginBottom + 'px 0px';

      var threshold = 0.5;
      var options = { rootMargin: rootMargin, threshold: threshold };
      var observer = new IntersectionObserver(intersectStep, options);

      observer.observe(step.node);
      step.observers.step = observer;
    }

    function updateStepObservers() {
      steps.forEach(updateStepObserver);
    }

    function updateProgressObserver(step) {
      var h = window.innerHeight;
      var off = step.offset || globalOffset;
      var factor = off.format === 'pixels' ? 1 : h;
      var offset = off.value * factor;
      var marginTop = -offset + step.height;
      var marginBottom = offset - h;
      var rootMargin = marginTop + 'px 0px ' + marginBottom + 'px 0px';

      var threshold = createProgressThreshold(step.height);
      var options = { rootMargin: rootMargin, threshold: threshold };
      var observer = new IntersectionObserver(intersectProgress, options);

      observer.observe(step.node);
      step.observers.progress = observer;
    }

    function updateProgressObservers() {
      steps.forEach(updateProgressObserver);
    }

    function updateObservers() {
      disconnectObservers();
      updateResizeObservers();
      updateStepObservers();
      if (isProgressMode) updateProgressObservers();
    }

    function disconnectObserver(_ref4) {
      var observers = _ref4.observers;

      Object.keys(observers).map(function (name) {
        observers[name].disconnect();
      });
    }

    function disconnectObservers() {
      steps.forEach(disconnectObserver);
    }

    /* SETUP FUNCTIONS */

    function indexSteps() {
      steps.forEach(function (step) {
        return step.node.setAttribute('data-scrollama-index', step.index);
      });
    }

    var S = {};

    S.setup = function (_ref5) {
      var step = _ref5.step,
          _ref5$offset = _ref5.offset,
          offset = _ref5$offset === undefined ? 0.5 : _ref5$offset,
          _ref5$threshold = _ref5.threshold,
          threshold = _ref5$threshold === undefined ? 4 : _ref5$threshold,
          _ref5$progress = _ref5.progress,
          progress = _ref5$progress === undefined ? false : _ref5$progress,
          _ref5$order = _ref5.order,
          order = _ref5$order === undefined ? true : _ref5$order,
          _ref5$once = _ref5.once,
          once = _ref5$once === undefined ? false : _ref5$once;

      steps = selectAll(step).map(function (node, index) {
        return {
          index: index,
          direction: undefined,
          height: node.offsetHeight,
          node: node,
          observers: {},
          offset: parseOffset(node.dataset.offset),
          progress: 0,
          state: undefined
        };
      });

      if (!steps.length) {
        err('no step elements');
        return S;
      }

      // options
      isProgressMode = progress;
      isTriggerOnce = once;
      progressThreshold = Math.max(1, +threshold);
      reset();
      indexSteps();
      S.offsetTrigger(offset);
      S.enable();
      return S;
    };

    S.resize = function () {
      handleResize();
      return S;
    };

    S.enable = function () {
      handleEnable(true);
      return S;
    };

    S.disable = function () {
      handleEnable(false);
      return S;
    };

    S.destroy = function () {
      handleEnable(false);
      reset();
    };

    S.offsetTrigger = function (x) {
      if (x === null || x === undefined) return globalOffset.value;
      globalOffset = parseOffset(x);
      return S;
    };

    S.onStepEnter = function (f) {
      if (typeof f === 'function') cb.stepEnter = f;else err('onStepEnter requires a function');
      return S;
    };

    S.onStepExit = function (f) {
      if (typeof f === 'function') cb.stepExit = f;else err('onStepExit requires a function');
      return S;
    };

    S.onStepProgress = function (f) {
      if (typeof f === 'function') cb.stepProgress = f;else err('onStepProgress requires a function');
      return S;
    };

    return S;
  }

  return scrollama;
});